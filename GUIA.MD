# Arquitectura Modular Basada en CaracterÃ­sticas (Feature-Based Architecture)
Componente,FunciÃ³n Principal,Â¿QuÃ© hace en tu Auth?
Module,Organizar y encapsular,Agrupa todo lo relacionado con usuarios y login.
DTO,Validar entrada,Revisa que el email sea un email real y la clave sea larga.
Guard,Autorizar acceso,Protege rutas como /perfil para que solo entren usuarios logueados.
Controller,Orquestar rutas,Define el endpoint /api/auth/register.
Service,LÃ³gica de negocio,Hashea la contraseÃ±a y guarda al usuario en la DB.
Entity,Definir datos,Crea la tabla users en tu base de datos de Docker.


## ğŸ“‹ Ãndice
1. [IntroducciÃ³n](#introducciÃ³n)
2. [Principios Clave](#principios-clave)
3. [Estructura de Carpetas](#estructura-de-carpetas)
4. [Componentes de un MÃ³dulo](#componentes-de-un-mÃ³dulo)
5. [CÃ³mo Implementarlo](#cÃ³mo-implementarlo)
6. [Patrones y Mejores PrÃ¡cticas](#patrones-y-mejores-prÃ¡cticas)
7. [Ejemplos PrÃ¡cticos](#ejemplos-prÃ¡cticos)

---

## IntroducciÃ³n

La **Arquitectura Modular Basada en CaracterÃ­sticas** es un patrÃ³n de diseÃ±o donde la aplicaciÃ³n se organiza alrededor de **dominios de negocio** en lugar de capas tÃ©cnicas.

### Nombres alternativos:
- **Feature-Based Architecture**
- **Domain-Driven Modules (DDD)**
- **Feature Modules**
- **Modular Monolith Architecture**

### Ventajas:
âœ… **Escalabilidad**: FÃ¡cil agregar nuevas funcionalidades sin afectar las existentes  
âœ… **Reusabilidad**: MÃ³dulos independientes pueden usarse en otros proyectos  
âœ… **Mantenibilidad**: LÃ³gica relacionada estÃ¡ en un mismo lugar  
âœ… **Testing**: Cada mÃ³dulo puede testearse de forma independiente  
âœ… **Claridad**: Estructura refleja el dominio del negocio  
âœ… **AutonomÃ­a de equipos**: Diferentes equipos pueden trabajar en mÃ³dulos diferentes  

---

## Principios Clave

### 1. **Independencia**
Cada mÃ³dulo debe ser lo mÃ¡s independiente posible. Si necesita funcionalidad de otro mÃ³dulo, debe importarlo explÃ­citamente.

### 2. **EncapsulaciÃ³n**
Un mÃ³dulo solo expone lo que necesita. Los internals (detalles de implementaciÃ³n) se mantienen privados.

### 3. **CohesiÃ³n Alta**
Toda la funcionalidad relacionada con una caracterÃ­stica estÃ¡ en su mÃ³dulo. Por ejemplo, todas las operaciones de productos estÃ¡n en `products/`.

### 4. **Acoplamiento Bajo**
Los mÃ³dulos tienen mÃ­nimas dependencias entre ellos. No hay dependencias circulares.

### 5. **Responsabilidad Ãšnica**
Cada mÃ³dulo tiene una Ãºnica razÃ³n para cambiar: cuando su dominio de negocio cambia.

---

## Estructura de Carpetas

### Estructura Recomendada por MÃ³dulo

```
src/
â”œâ”€â”€ auth/                          # MÃ³dulo de AutenticaciÃ³n
â”‚   â”œâ”€â”€ auth.controller.ts         # Endpoints HTTP
â”‚   â”œâ”€â”€ auth.service.ts            # LÃ³gica de negocio
â”‚   â”œâ”€â”€ auth.module.ts             # ConfiguraciÃ³n del mÃ³dulo
â”‚   â”œâ”€â”€ decorators/                # Decoradores personalizados
â”‚   â”‚   â”œâ”€â”€ auth.decorator.ts
â”‚   â”‚   â””â”€â”€ public.decorator.ts
â”‚   â”œâ”€â”€ dto/                       # Data Transfer Objects (entrada/salida)
â”‚   â”‚   â”œâ”€â”€ login.dto.ts
â”‚   â”‚   â”œâ”€â”€ register.dto.ts
â”‚   â”‚   â””â”€â”€ jwt-payload.dto.ts
â”‚   â”œâ”€â”€ entities/                  # Modelos de BD
â”‚   â”‚   â””â”€â”€ user.entity.ts
â”‚   â”œâ”€â”€ guards/                    # Guards (protecciÃ³n de rutas)
â”‚   â”‚   â”œâ”€â”€ auth.guard.ts
â”‚   â”‚   â””â”€â”€ jwt.guard.ts
â”‚   â”œâ”€â”€ interfaces/                # Interfaces TypeScript
â”‚   â”‚   â””â”€â”€ jwt-payload.interface.ts
â”‚   â””â”€â”€ strategies/                # Estrategias de Passport
â”‚       â””â”€â”€ jwt.strategy.ts
â”‚
â”œâ”€â”€ products/                      # MÃ³dulo de Productos
â”‚   â”œâ”€â”€ products.controller.ts
â”‚   â”œâ”€â”€ products.service.ts
â”‚   â”œâ”€â”€ products.module.ts
â”‚   â”œâ”€â”€ dto/
â”‚   â”‚   â”œâ”€â”€ create-product.dto.ts
â”‚   â”‚   â”œâ”€â”€ update-product.dto.ts
â”‚   â”‚   â””â”€â”€ pagination.dto.ts
â”‚   â”œâ”€â”€ entities/
â”‚   â”‚   â”œâ”€â”€ product.entity.ts
â”‚   â”‚   â””â”€â”€ product-image.entity.ts
â”‚   â””â”€â”€ helpers/                   # Funciones utilitarias del mÃ³dulo
â”‚       â””â”€â”€ product-helper.ts
â”‚
â”œâ”€â”€ files/                         # MÃ³dulo de GestiÃ³n de Archivos
â”‚   â”œâ”€â”€ files.controller.ts
â”‚   â”œâ”€â”€ files.service.ts
â”‚   â”œâ”€â”€ files.module.ts
â”‚   â”œâ”€â”€ dto/
â”‚   â”‚   â””â”€â”€ file-response.dto.ts
â”‚   â””â”€â”€ helpers/
â”‚       â””â”€â”€ file-storage.helper.ts
â”‚
â”œâ”€â”€ seed/                          # MÃ³dulo de Datos Iniciales
â”‚   â”œâ”€â”€ seed.controller.ts
â”‚   â”œâ”€â”€ seed.service.ts
â”‚   â”œâ”€â”€ seed.module.ts
â”‚   â””â”€â”€ data/
â”‚       â””â”€â”€ seed-data.ts
â”‚
â”œâ”€â”€ messages-ws/                   # MÃ³dulo de WebSockets
â”‚   â”œâ”€â”€ messages-ws.gateway.ts     # WebSocket Gateway
â”‚   â”œâ”€â”€ messages-ws.service.ts
â”‚   â”œâ”€â”€ messages-ws.module.ts
â”‚   â”œâ”€â”€ dto/
â”‚   â”‚   â””â”€â”€ message.dto.ts
â”‚   â””â”€â”€ interfaces/
â”‚       â””â”€â”€ message.interface.ts
â”‚
â”œâ”€â”€ common/                        # MÃ³dulo Compartido (Utilities)
â”‚   â”œâ”€â”€ common.module.ts
â”‚   â”œâ”€â”€ dtos/                      # DTOs reutilizables
â”‚   â”‚   â””â”€â”€ pagination.dto.ts
â”‚   â”œâ”€â”€ decorators/                # Decoradores globales
â”‚   â”œâ”€â”€ guards/                    # Guards globales
â”‚   â”œâ”€â”€ filters/                   # Exception Filters
â”‚   â”œâ”€â”€ interceptors/              # Interceptors
â”‚   â””â”€â”€ pipes/                     # Pipes personalizadas
â”‚
â”œâ”€â”€ app.module.ts                  # MÃ³dulo RaÃ­z
â””â”€â”€ main.ts                        # Punto de entrada
```

---

## Componentes de un MÃ³dulo

### 1. **Entity / Model**
Representa la estructura de datos en la base de datos.

```typescript
// products/entities/product.entity.ts
import { Column, Entity, PrimaryGeneratedColumn } from 'typeorm';

@Entity('products')
export class Product {
  @PrimaryGeneratedColumn('uuid')
  id: string;

  @Column('text', { unique: true })
  title: string;

  @Column('float', { default: 0 })
  price: number;

  @Column({ default: true })
  isActive: boolean;
}
```

### 2. **DTO (Data Transfer Object)**
Define la forma de los datos que entran/salen de la API.

```typescript
// products/dto/create-product.dto.ts
import { IsString, IsNumber, IsPositive } from 'class-validator';
import { ApiProperty } from '@nestjs/swagger';

export class CreateProductDto {
  @ApiProperty({
    description: 'TÃ­tulo del producto',
    example: 'Laptop Dell',
  })
  @IsString()
  title: string;

  @ApiProperty({
    description: 'Precio del producto',
    example: 999.99,
  })
  @IsNumber()
  @IsPositive()
  price: number;
}
```

### 3. **Service**
Contiene la lÃ³gica de negocio. Es el corazÃ³n del mÃ³dulo.

```typescript
// products/products.service.ts
import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { Product } from './entities/product.entity';
import { CreateProductDto } from './dto/create-product.dto';

@Injectable()
export class ProductsService {
  constructor(
    @InjectRepository(Product)
    private readonly productRepo: Repository<Product>,
  ) {}

  async create(createProductDto: CreateProductDto) {
    const product = this.productRepo.create(createProductDto);
    return await this.productRepo.save(product);
  }

  async findAll() {
    return await this.productRepo.find();
  }

  async findOne(id: string) {
    return await this.productRepo.findOneBy({ id });
  }

  async update(id: string, updateData: Partial<CreateProductDto>) {
    await this.productRepo.update(id, updateData);
    return this.findOne(id);
  }

  async delete(id: string) {
    const result = await this.productRepo.delete(id);
    return result.affected > 0;
  }
}
```

### 4. **Controller**
Maneja las rutas HTTP y delega la lÃ³gica al servicio.

```typescript
// products/products.controller.ts
import { Controller, Get, Post, Body, Param, Put, Delete } from '@nestjs/common';
import { ApiTags, ApiOperation } from '@nestjs/swagger';
import { ProductsService } from './products.service';
import { CreateProductDto } from './dto/create-product.dto';

@ApiTags('Products')
@Controller('products')
export class ProductsController {
  constructor(private readonly productsService: ProductsService) {}

  @Post()
  @ApiOperation({ summary: 'Crear un nuevo producto' })
  create(@Body() createProductDto: CreateProductDto) {
    return this.productsService.create(createProductDto);
  }

  @Get()
  @ApiOperation({ summary: 'Obtener todos los productos' })
  findAll() {
    return this.productsService.findAll();
  }

  @Get(':id')
  @ApiOperation({ summary: 'Obtener un producto por ID' })
  findOne(@Param('id') id: string) {
    return this.productsService.findOne(id);
  }

  @Put(':id')
  @ApiOperation({ summary: 'Actualizar un producto' })
  update(@Param('id') id: string, @Body() updateData: CreateProductDto) {
    return this.productsService.update(id, updateData);
  }

  @Delete(':id')
  @ApiOperation({ summary: 'Eliminar un producto' })
  delete(@Param('id') id: string) {
    return this.productsService.delete(id);
  }
}
```

### 5. **Module**
Encapsula el controlador, servicio y entidades. Define quÃ© se expone al resto de la aplicaciÃ³n.

```typescript
// products/products.module.ts
import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { ProductsController } from './products.controller';
import { ProductsService } from './products.service';
import { Product, ProductImage } from './entities';
import { AuthModule } from '../auth/auth.module';

@Module({
  controllers: [ProductsController],
  providers: [ProductsService],
  imports: [
    TypeOrmModule.forFeature([Product, ProductImage]),
    AuthModule, // Importar mÃ³dulo externo si es necesario
  ],
  exports: [
    ProductsService,    // Exportar para que otros mÃ³dulos lo usen
    TypeOrmModule,      // Exportar acceso a las entidades
  ],
})
export class ProductsModule {}
```

---

## CÃ³mo Implementarlo

### Paso 1: Generar la Estructura Base

```bash
# Crear la carpeta del mÃ³dulo
mkdir src/mi-modulo

# Crear archivos base
touch src/mi-modulo/{mi-modulo.module.ts,mi-modulo.controller.ts,mi-modulo.service.ts}
mkdir src/mi-modulo/{dto,entities,interfaces,decorators,guards}
```

### Paso 2: Definir la Entity

```typescript
// src/users/entities/user.entity.ts
import { Column, Entity, PrimaryGeneratedColumn } from 'typeorm';

@Entity('users')
export class User {
  @PrimaryGeneratedColumn('uuid')
  id: string;

  @Column('text', { unique: true })
  email: string;

  @Column('text')
  name: string;

  @Column('text')
  password: string; // Guardar hasheada siempre

  @Column({ default: true })
  isActive: boolean;

  @CreateDateColumn()
  createdAt: Date;
}
```

### Paso 3: Crear DTOs

```typescript
// src/users/dto/create-user.dto.ts
import { IsEmail, IsString, MinLength } from 'class-validator';

export class CreateUserDto {
  @IsEmail()
  email: string;

  @IsString()
  name: string;

  @IsString()
  @MinLength(8)
  password: string;
}

// src/users/dto/update-user.dto.ts
import { PartialType } from '@nestjs/mapped-types';
import { CreateUserDto } from './create-user.dto';

export class UpdateUserDto extends PartialType(CreateUserDto) {}
```

### Paso 4: Implementar el Servicio

```typescript
// src/users/users.service.ts
import { Injectable, BadRequestException } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { User } from './entities/user.entity';
import { CreateUserDto, UpdateUserDto } from './dto';
import * as bcrypt from 'bcrypt';

@Injectable()
export class UsersService {
  constructor(
    @InjectRepository(User)
    private readonly userRepo: Repository<User>,
  ) {}

  async create(createUserDto: CreateUserDto) {
    // Validar que no exista el email
    const exists = await this.userRepo.findOneBy({ email: createUserDto.email });
    if (exists) {
      throw new BadRequestException('Email already exists');
    }

    // Hashear la contraseÃ±a
    const hashedPassword = await bcrypt.hash(createUserDto.password, 10);

    const user = this.userRepo.create({
      ...createUserDto,
      password: hashedPassword,
    });

    return await this.userRepo.save(user);
  }

  async findAll() {
    return await this.userRepo.find({
      select: ['id', 'email', 'name', 'isActive', 'createdAt'],
    });
  }

  async findOne(id: string) {
    return await this.userRepo.findOneBy({ id });
  }

  async update(id: string, updateUserDto: UpdateUserDto) {
    const user = await this.findOne(id);
    if (!user) throw new BadRequestException('User not found');

    Object.assign(user, updateUserDto);
    return await this.userRepo.save(user);
  }

  async delete(id: string) {
    const result = await this.userRepo.delete(id);
    return result.affected > 0;
  }
}
```

### Paso 5: Crear el Controlador

```typescript
// src/users/users.controller.ts
import {
  Controller,
  Get,
  Post,
  Body,
  Param,
  Put,
  Delete,
  UseGuards,
} from '@nestjs/common';
import { ApiTags, ApiBearerAuth } from '@nestjs/swagger';
import { UsersService } from './users.service';
import { CreateUserDto, UpdateUserDto } from './dto';
import { JwtAuthGuard } from '../auth/guards/jwt.guard';

@ApiTags('Users')
@Controller('users')
export class UsersController {
  constructor(private readonly usersService: UsersService) {}

  @Post()
  create(@Body() createUserDto: CreateUserDto) {
    return this.usersService.create(createUserDto);
  }

  @Get()
  @UseGuards(JwtAuthGuard)
  @ApiBearerAuth()
  findAll() {
    return this.usersService.findAll();
  }

  @Get(':id')
  @UseGuards(JwtAuthGuard)
  findOne(@Param('id') id: string) {
    return this.usersService.findOne(id);
  }

  @Put(':id')
  @UseGuards(JwtAuthGuard)
  update(@Param('id') id: string, @Body() updateUserDto: UpdateUserDto) {
    return this.usersService.update(id, updateUserDto);
  }

  @Delete(':id')
  @UseGuards(JwtAuthGuard)
  delete(@Param('id') id: string) {
    return this.usersService.delete(id);
  }
}
```

### Paso 6: Crear el MÃ³dulo

```typescript
// src/users/users.module.ts
import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { UsersController } from './users.controller';
import { UsersService } from './users.service';
import { User } from './entities/user.entity';

@Module({
  controllers: [UsersController],
  providers: [UsersService],
  imports: [TypeOrmModule.forFeature([User])],
  exports: [UsersService, TypeOrmModule],
})
export class UsersModule {}
```

### Paso 7: Importar en App.Module

```typescript
// src/app.module.ts
import { Module } from '@nestjs/common';
import { ConfigModule } from '@nestjs/config';
import { TypeOrmModule } from '@nestjs/typeorm';
import { UsersModule } from './users/users.module';
import { ProductsModule } from './products/products.module';

@Module({
  imports: [
    ConfigModule.forRoot(),
    TypeOrmModule.forRoot({
      // ConfiguraciÃ³n...
      autoLoadEntities: true,
      synchronize: true,
    }),
    UsersModule,      // âœ… Agregar aquÃ­
    ProductsModule,
  ],
})
export class AppModule {}
```

---

## Patrones y Mejores PrÃ¡cticas

### 1. **ComunicaciÃ³n Entre MÃ³dulos**

âŒ **Incorrecto**: Acceder directamente a la BD de otro mÃ³dulo
```typescript
// âŒ MALO
@Injectable()
export class OrdersService {
  constructor(
    @InjectRepository(Product) 
    private productRepo: Repository<Product>, // NO - No pertenece a este mÃ³dulo
  ) {}
}
```

âœ… **Correcto**: Usar el servicio exportado del otro mÃ³dulo
```typescript
// âœ… BUENO
@Injectable()
export class OrdersService {
  constructor(
    private readonly productsService: ProductsService, // Usar servicio
  ) {}

  async createOrder(items: any[]) {
    for (const item of items) {
      const product = await this.productsService.findOne(item.productId);
      // Usar la lÃ³gica encapsulada
    }
  }
}
```

### 2. **Exports en MÃ³dulos**

```typescript
@Module({
  controllers: [ProductsController],
  providers: [ProductsService],
  imports: [TypeOrmModule.forFeature([Product, ProductImage])],
  exports: [
    ProductsService,      // âœ… Exportar servicio
    TypeOrmModule,        // âœ… Exportar acceso a entidades si es necesario
  ],
})
export class ProductsModule {}
```

### 3. **Manejo de Errores Consistente**

```typescript
// common/exceptions/custom.exception.ts
import { HttpException, HttpStatus } from '@nestjs/common';

export class ResourceNotFoundException extends HttpException {
  constructor(resource: string, id: any) {
    super(
      `${resource} with ID ${id} not found`,
      HttpStatus.NOT_FOUND,
    );
  }
}

// En el servicio:
async findOne(id: string) {
  const product = await this.productRepo.findOneBy({ id });
  if (!product) {
    throw new ResourceNotFoundException('Product', id);
  }
  return product;
}
```

### 4. **ValidaciÃ³n de Entrada (DTOs)**

```typescript
// Siempre validar entrada
export class PaginationDto {
  @IsOptional()
  @IsPositive()
  @Type(() => Number)
  limit?: number = 10;

  @IsOptional()
  @Min(0)
  @Type(() => Number)
  offset?: number = 0;
}

// En main.ts
app.useGlobalPipes(
  new ValidationPipe({
    whitelist: true,           // Eliminar propiedades no validadas
    forbidNonWhitelisted: true,// Error si hay propiedades extra
    transform: true,           // Transformar segÃºn DTOs
    transformOptions: {
      enableImplicitConversions: true,
    },
  }),
);
```

### 5. **Evitar Dependencias Circulares**

âŒ **Mal**:
```
auth.module -> imports -> products.module
products.module -> imports -> auth.module  // âŒ Circular
```

âœ… **Bien**: Crear un mÃ³dulo `common` para utilidades compartidas

```
auth.module -> imports -> common.module
products.module -> imports -> common.module
(Sin dependencia directa entre ellos)
```

---

## Ejemplos PrÃ¡cticos

### Ejemplo 1: MÃ³dulo de Pedidos (Orders)

```
src/orders/
â”œâ”€â”€ orders.module.ts
â”œâ”€â”€ orders.controller.ts
â”œâ”€â”€ orders.service.ts
â”œâ”€â”€ dto/
â”‚   â”œâ”€â”€ create-order.dto.ts
â”‚   â””â”€â”€ update-order.dto.ts
â”œâ”€â”€ entities/
â”‚   â””â”€â”€ order.entity.ts
â””â”€â”€ interfaces/
    â””â”€â”€ order.interface.ts
```

```typescript
// orders/orders.service.ts
@Injectable()
export class OrdersService {
  constructor(
    @InjectRepository(Order)
    private orderRepo: Repository<Order>,
    private readonly productsService: ProductsService,
    private readonly usersService: UsersService,
  ) {}

  async create(userId: string, createOrderDto: CreateOrderDto) {
    // Validar que el usuario existe
    const user = await this.usersService.findOne(userId);
    if (!user) throw new BadRequestException('User not found');

    // Validar que los productos existen
    for (const item of createOrderDto.items) {
      const product = await this.productsService.findOne(item.productId);
      if (!product) throw new BadRequestException(`Product ${item.productId} not found`);
    }

    // Crear la orden
    const order = this.orderRepo.create({
      userId,
      items: createOrderDto.items,
      total: createOrderDto.items.reduce((sum, item) => sum + item.quantity * item.price, 0),
    });

    return await this.orderRepo.save(order);
  }
}
```

### Ejemplo 2: MÃ³dulo de CategorÃ­as (Categories)

```typescript
// categories/categories.service.ts
@Injectable()
export class CategoriesService {
  constructor(
    @InjectRepository(Category)
    private categoryRepo: Repository<Category>,
  ) {}

  async findAll() {
    return await this.categoryRepo.find({
      relations: ['products'], // Cargar productos relacionados
    });
  }

  async findBySlug(slug: string) {
    return await this.categoryRepo.findOneBy({ slug });
  }
}

// categories/categories.module.ts
@Module({
  controllers: [CategoriesController],
  providers: [CategoriesService],
  imports: [TypeOrmModule.forFeature([Category])],
  exports: [CategoriesService, TypeOrmModule],
})
export class CategoriesModule {}
```

---

## Checklist para Crear un Nuevo MÃ³dulo

- [ ] Crear carpeta `src/nombre-modulo/`
- [ ] Definir Entity en `entities/nombre.entity.ts`
- [ ] Crear DTOs en `dto/` (Create, Update, Response)
- [ ] Implementar Service con lÃ³gica de negocio
- [ ] Crear Controller con rutas HTTP
- [ ] Crear Module y exportar lo necesario
- [ ] Importar Module en `app.module.ts`
- [ ] Agregar validaciÃ³n en DTOs
- [ ] Agregar documentaciÃ³n en Swagger
- [ ] Escribir tests (unit y e2e)
- [ ] Actualizar este documento si hay patrones nuevos

---

## ConclusiÃ³n

Esta arquitectura modular es altamente escalable y mantenible. Es ideal para equipos que trabajan en paralelo, proyectos que crecen con el tiempo, y cuando necesitas reutilizar cÃ³digo en mÃºltiples proyectos.

**Recuerda**: La clave estÃ¡ en:
- âœ… Baja dependencia entre mÃ³dulos
- âœ… Alta cohesiÃ³n dentro del mÃ³dulo
- âœ… Interfaces claras (exports)
- âœ… ValidaciÃ³n robusta (DTOs)
- âœ… Manejo de errores consistente
